<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grease Pencil Globe - Interactive</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050508; /* Deep Space */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            cursor: grab;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Prevents mobile scrolling */
        }
        body.grabbing {
            cursor: grabbing;
        }
        canvas {
            filter: blur(0.5px) contrast(1.1); 
        }
        .ui-layer {
            position: absolute;
            bottom: 30px;
            color: #556677;
            font-size: 12px;
            letter-spacing: 2px;
            pointer-events: none;
            text-align: center;
            width: 100%;
            text-transform: uppercase;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 14px;
            letter-spacing: 2px;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        #country-label {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            color: #FFFFFF; /* AI White */
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 4px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 0.3s;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="loading">ESTABLISHING ORBIT...</div>
    <div id="country-label"></div>
    <!-- <div class="ui-layer">Drag to Spin â€¢ Click a Country</div> -->

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const loadingEl = document.getElementById('loading');
    const labelEl = document.getElementById('country-label');

    let width, height;
    
    // Configuration
    let globeScale = 1; 
    const BASE_RADIUS = 220;
    const AUTO_ROTATION_SPEED = 0.002;
    const WAVE_SPEED = 0.05; 
    const SEGMENTS_LAT = 18; 
    const SEGMENTS_LON = 24; 
    const CLOUD_ALTITUDE = 25;
    const CLOUD_SPEED = 0.0007;
    
    // Visual Settings
    const JITTER_AMOUNT = 0.5; 
    const LINE_SEGMENT_LENGTH = 15; 
    
    // Colors
    const COLOR_GRID = 'rgba(0, 128, 128, 0.25)'; 
    const COLOR_MAP = '#008080';   // Default Deep Teal Outline
    const COLOR_WAVES = 'rgba(100, 255, 255, 0.3)'; // Lighter, more transparent waves
    const COLOR_LAND_SELECTED = '#00dcbe'; // Bright Teal for Selection
    const COLOR_SPACESHIP = 'rgba(220, 240, 255, 0.9)'; // Cool white for ship
    const COLOR_CLOUD = 'rgba(255, 255, 255, 0.85)'; // White outlines
    
    const GRID_WIDTH = 1.0;
    const MAP_WIDTH = 1.8;
    const WAVE_WIDTH = 1.5;
    const CLOUD_WIDTH = 1.8;

    // State
    let gridPoints = [];
    let countries = []; 
    let wavesData = []; 
    let stars = []; 
    let spaceshipStrokes = [];
    
    let rotationY = -1.5; 
    let rotationX = 0.3; 
    let waveOffset = 0; 
    let selectedCountryName = null; 
    
    // Interaction State
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let dragStartX = 0;
    let dragStartY = 0;
    let velocityX = 0;
    let velocityY = 0;
    let isPotentialClick = false;
    // Pinch Zoom State
    let initialPinchDist = null;
    let pinchStartScale = 1;

    // Animation
    let startTime = null;
    let entranceProgress = 0;
    let isDataLoaded = false;

    const GEOJSON_URL = 'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_110m_admin_0_countries.geojson';

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        ctx.translate(width / 2, height / 2);
        initStars();
    }

    function getSpherePoint(lat, lon, r) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180); 
        return {
            x: r * Math.sin(phi) * Math.cos(theta), 
            y: -r * Math.cos(phi), 
            z: r * Math.sin(phi) * Math.sin(theta)
        };
    }

    function initGrid() {
        gridPoints = [];
        for (let i = 0; i < SEGMENTS_LON; i++) {
            const theta = (i / SEGMENTS_LON) * Math.PI * 2;
            const line = [];
            for (let j = 0; j <= 30; j++) {
                const phi = (j / 30) * Math.PI;
                const r = BASE_RADIUS;
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = -r * Math.cos(phi);
                const z = r * Math.sin(phi) * Math.sin(theta);
                line.push({x, y, z});
            }
            gridPoints.push(line);
        }
        for (let i = 1; i < SEGMENTS_LAT; i++) {
            const phi = (i / SEGMENTS_LAT) * Math.PI;
            const line = [];
            for (let j = 0; j <= 40; j++) {
                const theta = (j / 40) * Math.PI * 2;
                const r = BASE_RADIUS;
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = -r * Math.cos(phi);
                const z = r * Math.sin(phi) * Math.sin(theta);
                line.push({x, y, z});
            }
            gridPoints.push(line);
        }
    }

    function initWaves() {
        wavesData = [];
        const numWaves = 150; 
        for (let i = 0; i < numWaves; i++) {
            const lat = (Math.random() - 0.5) * 160; 
            const lon = (Math.random() - 0.5) * 360;
            const span = 2 + Math.random() * 2; 
            wavesData.push({lat, lon, span});
        }
    }

    function initStars() {
        stars = [];
        const numStars = 400;
        for (let i = 0; i < numStars; i++) {
            stars.push({
                x: (Math.random() - 0.5) * width * 3, // Wider field for panning
                y: (Math.random() - 0.5) * height * 3,
                z: Math.random() * 2, // Depth factor
                size: Math.random() * 1.5,
                opacity: Math.random(),
                speed: 0.01 + Math.random() * 0.03 
            });
        }
    }


    // Realistic Grease Pencil Spaceship
    function initSpaceship() {
        spaceshipStrokes = [];
        const addStroke = (pts) => spaceshipStrokes.push(pts);

        // -- Main Fuselage (Flipped horizontally) --
        addStroke([{x: -80, y: 0}, {x: -60, y: -12}, {x: 20, y: -18}, {x: 70, y: -15}, {x: 80, y: -10}, {x: 80, y: 10}, {x: 70, y: 15}, {x: 20, y: 18}, {x: -60, y: 12}, {x: -80, y: 0}]);
        
        // Cockpit / Bridge (Flipped)
        addStroke([{x: -30, y: -10}, {x: -50, y: -5}, {x: -50, y: 5}, {x: -30, y: 10}, {x: -30, y: -10}]);
        addStroke([{x: -35, y: -10}, {x: -35, y: 10}]); 

        // -- Wings (Flipped) --
        addStroke([{x: 10, y: -18}, {x: 60, y: -60}, {x: 80, y: -60}, {x: 60, y: -16}]);
        addStroke([{x: 10, y: 18}, {x: 60, y: 60}, {x: 80, y: 60}, {x: 60, y: 16}]);
        addStroke([{x: 30, y: -30}, {x: 50, y: -30}]);
        addStroke([{x: 30, y: 30}, {x: 50, y: 30}]);

        // -- Engines (Flipped) --
        addStroke([{x: 80, y: -8}, {x: 95, y: -12}, {x: 95, y: 12}, {x: 80, y: 8}]);
        addStroke([{x: 80, y: -60}, {x: 85, y: -60}, {x: 85, y: -50}, {x: 80, y: -50}]); 
        addStroke([{x: 80, y: 60}, {x: 85, y: 60}, {x: 85, y: 50}, {x: 80, y: 50}]); 

        // -- Hull Details (Flipped) --
        addStroke([{x: 0, y: -18}, {x: 0, y: 18}]); 
        addStroke([{x: 40, y: -16}, {x: 40, y: 16}]);
        addStroke([{x: -10, y: -15}, {x: 5, y: -35}, {x: 5, y: -50}]);
    }

    async function loadMapData() {
        try {
            const response = await fetch(GEOJSON_URL);
            if (!response.ok) throw new Error('Network response was not ok');
            const data = await response.json();
            processGeoJSON(data);
            isDataLoaded = true;
            loadingEl.style.opacity = 0;
            setTimeout(() => loadingEl.remove(), 1000);
        } catch (error) {
            console.error('Error fetching map data:', error);
            loadingEl.textContent = "OFFLINE MODE";
            loadingEl.style.color = "#ff4444";
        }
    }

    function processGeoJSON(geojson) {
        countries = [];
        geojson.features.forEach(feature => {
            const name = feature.properties.name || feature.properties.admin || "Unknown";
            const geometry = feature.geometry;
            if (!geometry) return;
            
            const countryObj = { name: name, rings: [] };
            const type = geometry.type;
            const coords = geometry.coordinates;
            
            if (type === 'Polygon') {
                coords.forEach(ring => countryObj.rings.push(processRing(ring)));
            } else if (type === 'MultiPolygon') {
                coords.forEach(poly => poly.forEach(ring => countryObj.rings.push(processRing(ring))));
            }
            
            countries.push(countryObj);
        });
    }

    function processRing(ring) {
        const rawPoints = [];
        for (let i = 0; i < ring.length - 1; i++) {
            rawPoints.push({lat: ring[i][1], lon: ring[i][0]});
        }
        rawPoints.push({lat: ring[ring.length-1][1], lon: ring[ring.length-1][0]});
        
        const interpolated3D = [];
        for (let i = 0; i < rawPoints.length - 1; i++) {
            const p1 = rawPoints[i];
            const p2 = rawPoints[i+1];
            const dist = Math.hypot(p2.lon - p1.lon, p2.lat - p1.lat);
            const steps = Math.ceil(dist / 5); 
            
            for (let s = 0; s < steps; s++) {
                const t = s / steps;
                const lat = p1.lat + (p2.lat - p1.lat) * t;
                const lon = p1.lon + (p2.lon - p1.lon) * t;
                interpolated3D.push(getSpherePoint(lat, lon, BASE_RADIUS));
            }
        }
        
        return { raw: rawPoints, points3d: interpolated3D };
    }

    // --- Interaction ---

    function handleStart(x, y) {
        // Disable interaction during intro
        if (entranceProgress < 0.95) return;

        isDragging = true;
        isPotentialClick = true;
        lastMouseX = x;
        lastMouseY = y;
        dragStartX = x;
        dragStartY = y;
        document.body.classList.add('grabbing');
        velocityX = 0;
        velocityY = 0;
    }

    function handleMove(x, y) {
        if (!isDragging) return;
        
        const dx = x - dragStartX;
        const dy = y - dragStartY;
        
        if (Math.sqrt(dx*dx + dy*dy) > 5) {
            isPotentialClick = false;
        }

        const deltaX = x - lastMouseX;
        const deltaY = y - lastMouseY;
        
        rotationY += deltaX * 0.005; 
        rotationX += deltaY * 0.005;
        
        velocityX = deltaX * 0.005; 
        velocityY = deltaY * 0.005;

        lastMouseX = x;
        lastMouseY = y;
    }

    function handleEnd() {
        isDragging = false;
        document.body.classList.remove('grabbing');
    }
    
    function handleWheel(e) {
        if (entranceProgress < 0.95) return;
        globeScale += e.deltaY * -0.001;
        globeScale = Math.min(Math.max(.5, globeScale), 3);
    }
    
    function handleClick(e) {
        if (entranceProgress < 0.95) return;
        if (!isPotentialClick) return;

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left - width/2;
        const mouseY = e.clientY - rect.top - height/2;

        let bestCandidate = null;
        let minZ = Infinity;

        const maxRadiusSq = (BASE_RADIUS * globeScale * 1.2) ** 2;
        if (mouseX*mouseX + mouseY*mouseY > maxRadiusSq) return;

        countries.forEach(country => {
            country.rings.forEach(ringObj => {
                const ring3d = ringObj.points3d;
                const poly2d = [];
                let ringZSum = 0;
                let validPoints = 0;
                
                for(let i=0; i<ring3d.length; i+=2) {
                    const p = ring3d[i];
                    let r = rotateY(p, rotationY);
                    r = rotateX(r, rotationX);
                    const proj = project(r);
                    poly2d.push(proj);
                    ringZSum += proj.z;
                    if(proj.z <= 50) validPoints++;
                }
                
                if (validPoints < poly2d.length * 0.5) return; 
                const avgZ = ringZSum / poly2d.length;
                if (avgZ > 50) return; 

                let inside = false;
                for (let i = 0, j = poly2d.length - 1; i < poly2d.length; j = i++) {
                    const xi = poly2d[i].x, yi = poly2d[i].y;
                    const xj = poly2d[j].x, yj = poly2d[j].y;
                    const intersect = ((yi > mouseY) !== (yj > mouseY))
                        && (mouseX < (xj - xi) * (mouseY - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }

                if (inside && avgZ < minZ) {
                    minZ = avgZ;
                    bestCandidate = country.name;
                }
            });
        });

        if (bestCandidate) {
            selectedCountryName = bestCandidate;
            labelEl.textContent = bestCandidate;
            labelEl.style.opacity = 1;
            labelEl.style.transform = "translateX(-50%) scale(1.1)";
            setTimeout(() => labelEl.style.transform = "translateX(-50%) scale(1)", 100);
        }
    }

    window.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', handleEnd);
    window.addEventListener('click', handleClick);
    window.addEventListener('wheel', handleWheel);
    
    window.addEventListener('touchstart', e => {
        if (e.touches.length === 2) {
            isDragging = false; 
            isPotentialClick = false; 
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            initialPinchDist = Math.hypot(dx, dy);
            pinchStartScale = globeScale;
        } else if (e.touches.length === 1) {
            handleStart(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false });
    
    window.addEventListener('touchmove', e => {
        e.preventDefault(); 
        if (e.touches.length === 2 && initialPinchDist) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            const scaleChange = dist / initialPinchDist;
            globeScale = Math.min(Math.max(0.5, pinchStartScale * scaleChange), 3);
        } else if (e.touches.length === 1) {
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false });
    
    window.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) initialPinchDist = null;
        if (e.touches.length === 0) {
            handleEnd();
            if (isPotentialClick && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                handleClick({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                isPotentialClick = false; 
            }
        }
    }, { passive: false });

    // --- Drawing Functions ---

    function rotateY(p, theta) {
        return {
            x: p.x * Math.cos(theta) - p.z * Math.sin(theta),
            y: p.y,
            z: p.x * Math.sin(theta) + p.z * Math.cos(theta)
        };
    }

    function rotateX(p, theta) {
        return {
            x: p.x,
            y: p.y * Math.cos(theta) - p.z * Math.sin(theta),
            z: p.y * Math.sin(theta) + p.z * Math.cos(theta)
        };
    }

    function project(p) {
        // Apply entrance zoom effect
        const entranceZoom = 0.1 + entranceProgress * 0.9;
        
        const scale = (800 / (800 + p.z)) * globeScale * entranceZoom;
        return {
            x: p.x * scale,
            y: p.y * scale,
            z: p.z,
            scale: scale
        };
    }

    function easeOutExpo(x) {
        return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
    }

    // --- Render Loop ---
    
    function renderFrame(timestamp) {
        if (!startTime) startTime = timestamp;
        // 3 seconds duration for entrance
        const rawProgress = Math.min((timestamp - startTime) / 3500, 1);
        entranceProgress = easeOutExpo(rawProgress);

        const speedShake = (1 - entranceProgress) * 2; 

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, width, height);
        
        const panOffset = (1 - entranceProgress) * -width * 0.8; 
        
        ctx.save();
        const shakeX = (Math.random() - 0.5) * speedShake;
        const shakeY = (Math.random() - 0.5) * speedShake;
        ctx.translate(width/2 + shakeX, height/2 + shakeY);

        // Draw Stars
        ctx.fillStyle = '#ffffff';
        stars.forEach(star => {
            ctx.globalAlpha = star.opacity * (0.5 + Math.random() * 0.5);
            
            let starX = star.x + panOffset * star.z * 0.5; // Parallax
            
            ctx.beginPath();
            if (entranceProgress < 0.8) {
                ctx.rect(starX, star.y, star.size + (1-entranceProgress)*50, star.size);
            } else {
                ctx.arc(starX, star.y, star.size, 0, Math.PI * 2);
            }
            ctx.fill();
        });
        ctx.globalAlpha = 1.0;

        // --- Globe Layer ---
        ctx.translate(panOffset, 0);

        if (!isDragging && entranceProgress > 0.9) {
            rotationY -= AUTO_ROTATION_SPEED; 
            if (Math.abs(velocityX) > 0.0001 || Math.abs(velocityY) > 0.0001) {
                rotationY += velocityX;
                rotationX += velocityY;
                velocityX *= 0.95;
                velocityY *= 0.95;
            }
        }
        
        waveOffset += WAVE_SPEED;

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        const drawBatch = (lines, color, width, isGrid, jitterScale = 1.0) => {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;

            const jitterFactor = (isGrid ? JITTER_AMOUNT : JITTER_AMOUNT * 0.5) * jitterScale;

            lines.forEach(line => {
                let prevPt = null;
                let isLineActive = false;

                for (let i=0; i<line.length; i++) {
                    const p = line[i];
                    let r = rotateY(p, rotationY);
                    r = rotateX(r, rotationX);
                    
                    if (r.z > 50) { 
                        prevPt = null;
                        isLineActive = false;
                        continue; 
                    }

                    const proj = project(r);

                    if (prevPt) {
                        const dist = Math.abs(proj.x - prevPt.x) + Math.abs(proj.y - prevPt.y);
                        
                        if (!isLineActive) {
                            ctx.moveTo(prevPt.x, prevPt.y);
                            isLineActive = true;
                        }

                        if (dist < 5) {
                            ctx.lineTo(proj.x, proj.y);
                        } else {
                            const steps = Math.floor(dist / LINE_SEGMENT_LENGTH);
                            if (steps > 0) {
                                for (let s = 1; s <= steps; s++) {
                                    const t = s / (steps + 1);
                                    let tx = prevPt.x + (proj.x - prevPt.x) * t;
                                    let ty = prevPt.y + (proj.y - prevPt.y) * t;
                                    
                                    tx += (Math.random() - 0.5) * jitterFactor * 2;
                                    ty += (Math.random() - 0.5) * jitterFactor * 2;
                                    
                                    ctx.lineTo(tx, ty);
                                }
                            }
                            ctx.lineTo(proj.x, proj.y);
                        }
                    }
                    prevPt = proj;
                }
            });
            ctx.stroke();
        };

        // 2. Grid
        drawBatch(gridPoints, COLOR_GRID, GRID_WIDTH, true);
        
        // 3. Waves (Animated)
        const currentWaveLines = wavesData.map(w => {
            const currentLon = w.lon + waveOffset;
            const waveRadius = BASE_RADIUS * 1.005; 
            return [
                getSpherePoint(w.lat, currentLon - w.span, waveRadius),
                getSpherePoint(w.lat, currentLon, waveRadius),
                getSpherePoint(w.lat, currentLon + w.span, waveRadius)
            ];
        });
        drawBatch(currentWaveLines, COLOR_WAVES, WAVE_WIDTH, true);

        // 4. Map Outlines
        if (isDataLoaded) {
            const unselectedRings = [];
            const selectedRings = [];

            countries.forEach(c => {
                if (c.name === selectedCountryName) {
                    selectedRings.push(...c.rings.map(r => r.points3d));
                } else {
                    unselectedRings.push(...c.rings.map(r => r.points3d));
                }
            });

            if(unselectedRings.length > 0) {
                drawBatch(unselectedRings, COLOR_MAP, MAP_WIDTH, false);
            }
            
            if(selectedRings.length > 0) {
                drawBatch(selectedRings, COLOR_LAND_SELECTED, MAP_WIDTH * 1.8, false);
            }
        }

        // --- Spaceship (Foreground) ---
        ctx.restore(); 
        
        ctx.save();
        // Move to right side
        ctx.translate(width * 0.85, height * 0.5);
        
        const shipY = (Math.cos(timestamp * 0.001) * 10); 
        const shipRot = Math.sin(timestamp * 0.0005) * 0.05;
        const shipScale = 0.6 + entranceProgress * 0.2; 

        ctx.translate(0, shipY);
        ctx.scale(shipScale, shipScale);
        // Negative rotation to tilt up-left
        ctx.rotate(shipRot - Math.PI/24); 

        // Draw Spaceship
        ctx.beginPath();
        ctx.strokeStyle = COLOR_SPACESHIP;
        ctx.lineWidth = 1.5;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        spaceshipStrokes.forEach(stroke => {
            if(stroke.length < 2) return;
            
            let lx = stroke[0].x;
            let ly = stroke[0].y;
            ctx.moveTo(lx, ly);
            
            for(let i=1; i<stroke.length; i++) {
                const p = stroke[i];
                const dist = Math.hypot(p.x - lx, p.y - ly);
                const steps = Math.max(1, Math.floor(dist / 5));
                
                for(let k=1; k<=steps; k++) {
                    const t = k/steps;
                    let tx = lx + (p.x - lx)*t;
                    let ty = ly + (p.y - ly)*t;
                    tx += (Math.random()-0.5)*1;
                    ty += (Math.random()-0.5)*1;
                    ctx.lineTo(tx, ty);
                }
                lx = p.x;
                ly = p.y;
            }
        });
        ctx.stroke();
        ctx.restore();

        requestAnimationFrame(renderFrame);
    }

    window.addEventListener('resize', resize);
    resize();
    initGrid();
    initWaves(); 
    initStars();
    initSpaceship();
    loadMapData();
    requestAnimationFrame(renderFrame);

</script>
</body>
</html>
