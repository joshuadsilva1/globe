<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grease Pencil Globe - Interactive</title>
    
    <!-- Import DM Sans Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:opsz,wght@9..40,400;9..40,500;9..40,700&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050508; /* Deep Space */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            cursor: grab;
            font-family: 'Courier New', Courier, monospace; /* Default font for loading/labels */
            touch-action: none; /* Prevents mobile scrolling */
        }
        body.grabbing {
            cursor: grabbing;
        }
        canvas {
            filter: blur(0.5px) contrast(1.1); 
        }
        
        /* APP TITLE (Top Left) */
        #app-title {
            position: absolute;
            top: 30px;
            left: 40px;
            color: #b9bfc3;
            font-family: 'DM Sans', sans-serif;
            font-weight: 700;
            font-size: 14px;
            letter-spacing: 2px;
            pointer-events: none;
            z-index: 10;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 14px;
            letter-spacing: 2px;
            pointer-events: none;
            transition: opacity 0.5s;
            text-align: center;
            width: 100%;
        }
        #country-label {
            position: absolute;
            top: 15%;
            left: 50%;
            transform: translateX(-50%);
            color: #FFFFFF; /* AI White */
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 4px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            text-transform: uppercase;
            opacity: 0;
            transition: opacity 0.3s;
        }
        /* POPUP STYLES */
        #info-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            /* Very Translucent #b9bfc3 (Glass Effect) */
            background-color: rgba(185, 191, 195, 0.15); 
            color: #f0f0f0; 
            padding: 20px 30px;
            border-radius: 20px; 
            /* UPDATED FONT FAMILY */
            font-family: 'DM Sans', sans-serif; 
            font-weight: 500;
            pointer-events: none; 
            opacity: 0;
            transform: translate(-50%, -50%) scale(0); 
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); 
            z-index: 100;
            backdrop-filter: blur(15px); /* Increased blur for glass effect */
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.5);
            text-align: left; 
            min-width: 240px;
            max-width: 340px; 
            border: 1px solid rgba(255, 255, 255, 0.15); /* Subtle light border */
            overflow: visible; 
            line-height: 1.5; 
        }
        
        /* Echo Ripples Animation */
        #info-popup::before, #info-popup::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            border-radius: 20px;
            border: 2px solid rgba(255, 120, 105, 0.8); /* Match pointer color #ff7869 */
            opacity: 0;
            z-index: -1;
        }

        #info-popup.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2); 
            pointer-events: auto; /* Enable clicks inside popup */
        }
        
        #info-popup.active::before {
            animation: echoExpand 2s 1 cubic-bezier(0, 0.2, 0.8, 1);
        }
        #info-popup.active::after {
            animation: echoExpand 2s 1 cubic-bezier(0, 0.2, 0.8, 1) 0.5s;
        }

        @keyframes echoExpand {
            0% {
                transform: scale(1);
                opacity: 0.8;
                border-width: 4px;
            }
            100% {
                transform: scale(1.6);
                opacity: 0;
                border-width: 0px;
            }
        }

        #info-popup .title {
            font-size: 1.4em;
            text-transform: uppercase;
            text-align: center; 
            display: block;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255,255,255,0.2); /* Light divider */
            padding-bottom: 10px;
            color: #ff7869; /* Pointer color for title */
            letter-spacing: 1px;
            font-weight: 700;
        }
        #info-popup .subtitle {
            font-size: 0.85em;
            opacity: 0.8;
            font-weight: 400;
            letter-spacing: 0.5px;
            display: block;
            text-align: center;
            color: #ddd; /* Light grey */
        }
        
        #info-popup .content-section {
            font-size: 13px; 
            margin-top: 8px;
            color: #f0f0f0; /* White text for readability on dark glass */
            max-height: 250px;
            overflow-y: auto;
            padding-right: 5px;
        }
        #info-popup .org-name {
            color: #00dcbe; /* Bright Teal highlight */
            font-weight: 700;
            margin-top: 12px;
            display: block;
            margin-bottom: 4px;
        }
        #info-popup .quote {
            font-style: italic;
            opacity: 0.9;
            margin-bottom: 8px;
            display: block;
            padding-left: 12px;
            /* Removed border-left as requested */
            color: #e0e0e0;
        }
    </style>
</head>
<body>
    <div id="app-title">GH VOICE OF CUSTOMERS</div>
    <canvas id="canvas"></canvas>
    <div id="loading">VOICE OF CUSTOMERS</div>
    <div id="country-label"></div>
    <div id="info-popup"></div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const loadingEl = document.getElementById('loading');
    const labelEl = document.getElementById('country-label');
    const popupEl = document.getElementById('info-popup');

    let width, height;
    
    // Configuration
    let globeScale = 1; 
    const BASE_RADIUS = 220;
    const AUTO_ROTATION_SPEED = 0.001;
    const WAVE_SPEED = 0.05; 
    const SEGMENTS_LAT = 18; 
    const SEGMENTS_LON = 24; 
    const GEOJSON_URL = 'https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_110m_admin_0_countries.geojson';
    
    // Visual Settings
    const JITTER_AMOUNT = 0.5; 
    const LINE_SEGMENT_LENGTH = 20; 
    
    // Colors
    const COLOR_GRID = 'rgba(0, 128, 128, 0.25)'; 
    const COLOR_MAP = '#008080';   // Default Deep Teal Outline
    const COLOR_WAVES = 'rgba(100, 255, 255, 0.3)'; // Lighter, more transparent waves
    const COLOR_LAND_SELECTED = '#00dcbe'; // Bright Teal for Selection
    const COLOR_POINTER = '#ff7869'; // Speaking Head Color
    
    const GRID_WIDTH = 1.0;
    const MAP_WIDTH = 1.8;
    const WAVE_WIDTH = 1.5;

    // State
    let gridPoints = [];
    let countries = []; 
    let wavesData = []; 
    let stars = []; 
    
    // Pointers Data with Content
    const pointers = [
        { 
            name: "Benin", lat: 9.30, lon: 2.31,
            content: `
                <span class="org-name">Kalalé Healthcare Center – Dr. Dagoussi Babatunde</span>
                <span class="quote">“We see ~90% concordance between AI and GeneXpert.”</span>
                <span class="quote">“Patients improve within week 1 when treatment starts early.”</span>
                <span class="org-name">Kérou Healthcare Center – Dr. Ulrich</span>
                <span class="quote">“Accuracy has improved significantly — AI is now central to daily work.”</span>
                <span class="quote">“Before AI, patients traveled 75 km for X-rays.”</span>
            `
        },
        { 
            name: "Zambia", lat: -13.13, lon: 27.84,
            content: `
                <span class="org-name">Masanso Mini Hospital – Clinical Team</span>
                <span class="quote">“AI flagged 146 presumptive TB cases out of 1,584 screenings.”</span>
                <span class="quote">“The system has improved patient management beyond TB.”</span>
                <span class="org-name">Martin (Radiographer, Masanso)</span>
                <span class="quote">“AI rapidly identifies individuals for microbiological testing.”</span>
                <span class="quote">“It has strengthened our diagnostic capacity.”</span>
            `
        },
        { 
            name: "Malawi", lat: -13.25, lon: 34.30,
            content: `
                <span class="org-name">Euthini Community Hospital – Dr. Steve</span>
                <span class="quote">“AI has improved diagnosis and follow-up a lot.”</span>
                <span class="quote">“Positives rose from 7 (2022) to 24 (2023) with AI.”</span>
                <span class="quote">“When sputum is negative but AI is positive, it guides us to treat.”</span>
                <span class="quote">“Patients previously had to travel about 90km for an X-ray... now help is available here.”</span>
            `
        },
        { 
            name: "Ethiopia", lat: 9.14, lon: 40.48,
            content: `
                <span class="org-name">Arbaminch Correctional Facility – TB Coordinator</span>
                <span class="quote">“Among 84 inmates, AI found 2 TB presumptives and 4 abnormalities.”</span>
                <span class="org-name">Pollypharma – Michael Teruku</span>
                <span class="quote">“Training was powerful; AI simplifies and speeds up TB detection.”</span>
                <span class="quote">“A big appreciation to Qure and MinXray.”</span>
            `
        },
        { 
            name: "India", lat: 20.59, lon: 81.08,
            content: `
                <span class="org-name">Shaheed Hospital – Dr. Saibal Jana</span>
                <span class="quote">“Critical for identifying TB early and reducing diagnosis-to-treatment time.”</span>
                <span class="quote">“Enables transition from physical registers to digital systems in mining communities.”</span>
            `
        },
        { 
            name: "Philippines", lat: 12.87, lon: 121.77,
            content: `
                <span class="org-name">PBSP / Global Fund</span>
                <span class="quote">“X-ray-first works — 37% of screened cases were presumptive TB.”</span>
                <span class="quote">“We screened 39,000 people with 179 confirmed TB cases.”</span>
                <span class="org-name">PBSP Operations Team</span>
                <span class="quote">“Mobile vans + AI have expanded lung screening massively.”</span>
            `
        },
        { 
            name: "Vietnam", lat: 14.05, lon: 108.27,
            content: `
                <span class="org-name">FIT Vietnam Program Manager</span>
                <span class="quote">“qTrack is performing well in asymptomatic cohorts — exciting results.”</span>
                <span class="quote">“One site completed 52,000 scans with 5,300 presumptives.”</span>
                <span class="quote">“Now planning AI-guided ‘pooled testing’ to save costs in low-prevalence settings.”</span>
            `
        },
        { 
            name: "Sri Lanka", lat: 7.87, lon: 80.77,
            content: `
                <span class="org-name">NPTCCD Sri Lanka – OPD Team</span>
                <span class="quote">“We screened 4,747 people, and AI flagged 959 TB presumptives.”</span>
                <span class="quote">“qXR is gaining strong interest within OPD workflows.”</span>
            `
        },
        { 
            name: "Thailand", lat: 15.87, lon: 100.99,
            content: `
                <span class="org-name">Khon Kaen Correctional Facility – Medical Team</span>
                <span class="quote">“We screen 200 prisoners per week; AI helps flag presumptives quickly.”</span>
                <span class="org-name">Phetchabun Provincial Prison – Radiology Team</span>
                <span class="quote">“We plan 5,400 scans in six months — AI will guide clinical decisions.”</span>
                <span class="org-name">Khao Phrik Prison – Dr. Chatra</span>
                <span class="quote">“AI will improve the lives of both prisoners and radiologists.”</span>
            `
        },
        { 
            name: "Nigeria", lat: 9.08, lon: 8.67, 
            content: `
                <span class="org-name">Kebbi • Jigawa • Gombe • RedAid Sites</span>
                <span class="quote">“AI has transformed TB screening across Nigeria. In Kebbi, it helped detect 300+ TB cases from 6,000+ scans, and when AI flags a case, GeneXpert is rarely negative. Jigawa saw a breakthrough shift from needing 150 samples for 7–8 positives to getting 6–7 positives from just 10 samples. Gombe improved from 1:10–11 to 1:6 and reduced turnaround time from 1 week to 48 hours. Across RedAid sites, AI is catching cases symptom screening misses and helping teams save more lives, with radiographers calling it ‘innovation meeting humanity.’”</span>
            `
        }
    ];
    
    let rotationY = -1.5; 
    let rotationX = 0.3; 
    let waveOffset = 0; 
    let selectedCountryName = null; 
    
    // Interaction State
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let dragStartX = 0;
    let dragStartY = 0;
    let velocityX = 0;
    let velocityY = 0;
    let isPotentialClick = false;
    // Pinch Zoom State
    let initialPinchDist = null;
    let pinchStartScale = 1;

    // Animation
    let startTime = null;
    let entranceProgress = 0;
    let isDataLoaded = false;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        ctx.translate(width / 2, height / 2);
        initStars();
    }

    function getSpherePoint(lat, lon, r) {
        const phi = (90 - lat) * (Math.PI / 180);
        const theta = (lon + 180) * (Math.PI / 180); 
        return {
            x: r * Math.sin(phi) * Math.cos(theta), 
            y: -r * Math.cos(phi), 
            z: r * Math.sin(phi) * Math.sin(theta)
        };
    }

    function initGrid() {
        gridPoints = [];
        for (let i = 0; i < SEGMENTS_LON; i++) {
            const theta = (i / SEGMENTS_LON) * Math.PI * 2;
            const line = [];
            for (let j = 0; j <= 30; j++) {
                const phi = (j / 30) * Math.PI;
                const r = BASE_RADIUS;
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = -r * Math.cos(phi);
                const z = r * Math.sin(phi) * Math.sin(theta);
                line.push({x, y, z});
            }
            gridPoints.push(line);
        }
        for (let i = 1; i < SEGMENTS_LAT; i++) {
            const phi = (i / SEGMENTS_LAT) * Math.PI;
            const line = [];
            for (let j = 0; j <= 40; j++) {
                const theta = (j / 40) * Math.PI * 2;
                const r = BASE_RADIUS;
                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = -r * Math.cos(phi);
                const z = r * Math.sin(phi) * Math.sin(theta);
                line.push({x, y, z});
            }
            gridPoints.push(line);
        }
    }

    function initWaves() {
        wavesData = [];
        const numWaves = 150; 
        for (let i = 0; i < numWaves; i++) {
            const lat = (Math.random() - 0.5) * 160; 
            const lon = (Math.random() - 0.5) * 360;
            const span = 2 + Math.random() * 2; 
            wavesData.push({lat, lon, span});
        }
    }

    function initStars() {
        stars = [];
        const numStars = 400;
        for (let i = 0; i < numStars; i++) {
            stars.push({
                x: (Math.random() - 0.5) * width * 3, 
                y: (Math.random() - 0.5) * height * 3,
                z: Math.random() * 2, 
                size: Math.random() * 1.5,
                opacity: Math.random(),
                speed: 0.01 + Math.random() * 0.03 
            });
        }
    }

    async function loadMapData() {
        try {
            const response = await fetch(GEOJSON_URL);
            if (!response.ok) throw new Error('Network response was not ok');
            const data = await response.json();
            processGeoJSON(data);
            isDataLoaded = true;
            
            // Handled by loading sequence now
        } catch (error) {
            console.error('Error fetching map data:', error);
            loadingEl.textContent = "OFFLINE MODE";
            loadingEl.style.color = "#ff4444";
        }
    }
    
    function startLoadingSequence() {
        loadingEl.textContent = "VOICE OF CUSTOMERS";
        
        // 2 seconds for first message
        setTimeout(() => {
            loadingEl.textContent = "AN INITIATIVE BY GLOBAL HEALTH CS";
            
            // 2 seconds for second message
            setTimeout(() => {
                // Wait for data if not ready
                const checkData = setInterval(() => {
                    if (isDataLoaded) {
                        loadingEl.style.opacity = 0;
                        setTimeout(() => loadingEl.style.display = 'none', 500);
                        clearInterval(checkData);
                    }
                }, 100);
            }, 2000);
        }, 2000);
    }

    function processGeoJSON(geojson) {
        countries = [];
        geojson.features.forEach(feature => {
            const name = feature.properties.name || feature.properties.admin || "Unknown";
            const geometry = feature.geometry;
            if (!geometry) return;
            
            const countryObj = { name: name, rings: [] };
            const type = geometry.type;
            const coords = geometry.coordinates;
            
            if (type === 'Polygon') {
                coords.forEach(ring => countryObj.rings.push(processRing(ring)));
            } else if (type === 'MultiPolygon') {
                coords.forEach(poly => poly.forEach(ring => countryObj.rings.push(processRing(ring))));
            }
            
            countries.push(countryObj);
        });
    }

    function processRing(ring) {
        const rawPoints = [];
        for (let i = 0; i < ring.length - 1; i++) {
            rawPoints.push({lat: ring[i][1], lon: ring[i][0]});
        }
        rawPoints.push({lat: ring[ring.length-1][1], lon: ring[ring.length-1][0]});
        
        const interpolated3D = [];
        for (let i = 0; i < rawPoints.length - 1; i++) {
            const p1 = rawPoints[i];
            const p2 = rawPoints[i+1];
            const dist = Math.hypot(p2.lon - p1.lon, p2.lat - p1.lat);
            const steps = Math.ceil(dist / 5); 
            
            for (let s = 0; s < steps; s++) {
                const t = s / steps;
                const lat = p1.lat + (p2.lat - p1.lat) * t;
                const lon = p1.lon + (p2.lon - p1.lon) * t;
                interpolated3D.push(getSpherePoint(lat, lon, BASE_RADIUS));
            }
        }
        
        return { raw: rawPoints, points3d: interpolated3D };
    }

    // --- Interaction ---

    function handleStart(x, y) {
        if (entranceProgress < 0.95) return;

        isDragging = true;
        isPotentialClick = true;
        lastMouseX = x;
        lastMouseY = y;
        dragStartX = x;
        dragStartY = y;
        document.body.classList.add('grabbing');
        
        // Hide popup on drag start
        popupEl.classList.remove('active');
    }

    function handleMove(x, y) {
        if (!isDragging) return;
        
        const dx = x - dragStartX;
        const dy = y - dragStartY;
        
        if (Math.sqrt(dx*dx + dy*dy) > 5) {
            isPotentialClick = false;
        }

        const deltaX = x - lastMouseX;
        const deltaY = y - lastMouseY;
        
        rotationY += deltaX * 0.005; 
        rotationX += deltaY * 0.005;
        
        velocityX = deltaX * 0.005; 
        velocityY = deltaY * 0.005;

        lastMouseX = x;
        lastMouseY = y;
    }

    function handleEnd() {
        isDragging = false;
        document.body.classList.remove('grabbing');
    }
    
    function handleWheel(e) {
        if (entranceProgress < 0.95) return;
        globeScale += e.deltaY * -0.001;
        globeScale = Math.min(Math.max(.5, globeScale), 3);
        
        // Hide popup on zoom
        popupEl.classList.remove('active');
    }
    
    function handleClick(e) {
        if (entranceProgress < 0.95) return;
        if (!isPotentialClick) return;

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left - width/2;
        const mouseY = e.clientY - rect.top - height/2;

        let bestCandidate = null;
        let minZ = Infinity;

        const maxRadiusSq = (BASE_RADIUS * globeScale * 1.2) ** 2;
        
        if (mouseX*mouseX + mouseY*mouseY < maxRadiusSq) {
            countries.forEach(country => {
                country.rings.forEach(ringObj => {
                    const ring3d = ringObj.points3d;
                    const poly2d = [];
                    let ringZSum = 0;
                    let validPoints = 0;
                    
                    for(let i=0; i<ring3d.length; i+=2) {
                        const p = ring3d[i];
                        let r = rotateY(p, rotationY);
                        r = rotateX(r, rotationX);
                        const proj = project(r);
                        poly2d.push(proj);
                        ringZSum += proj.z;
                        if(proj.z <= 50) validPoints++;
                    }
                    
                    if (validPoints < poly2d.length * 0.5) return; 
                    const avgZ = ringZSum / poly2d.length;
                    if (avgZ > 50) return; 

                    let inside = false;
                    for (let i = 0, j = poly2d.length - 1; i < poly2d.length; j = i++) {
                        const xi = poly2d[i].x, yi = poly2d[i].y;
                        const xj = poly2d[j].x, yj = poly2d[j].y;
                        const intersect = ((yi > mouseY) !== (yj > mouseY))
                            && (mouseX < (xj - xi) * (mouseY - yi) / (yj - yi) + xi);
                        if (intersect) inside = !inside;
                    }

                    if (inside && avgZ < minZ) {
                        minZ = avgZ;
                        bestCandidate = country.name;
                    }
                });
            });
        }

        if (bestCandidate) {
            selectedCountryName = bestCandidate;
            
            // Check if this country has a pointer
            const pointerData = pointers.find(p => p.name === bestCandidate);
            
            if (pointerData) {
                // Hide the main background label to avoid overlap
                labelEl.style.opacity = 0;

                // HTML Content for Popup
                let htmlContent = `<span class="title">${bestCandidate}</span>`;
                if (pointerData.content) {
                    htmlContent += `<div class="content-section">${pointerData.content}</div>`;
                } else {
                    htmlContent += `<br><span class="subtitle">Voice of Customer</span>`;
                }

                popupEl.innerHTML = htmlContent;
                popupEl.classList.add('active');
            } else {
                // Show default label if no popup content
                labelEl.textContent = bestCandidate;
                labelEl.style.opacity = 1;
                labelEl.style.transform = "translateX(-50%) scale(1.1)";
                setTimeout(() => labelEl.style.transform = "translateX(-50%) scale(1)", 100);
                
                popupEl.classList.remove('active');
            }
        } else {
            // Clicked background, hide popup
            popupEl.classList.remove('active');
        }
    }

    window.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', handleEnd);
    window.addEventListener('click', handleClick);
    window.addEventListener('wheel', handleWheel);
    
    window.addEventListener('touchstart', e => {
        if (e.touches.length === 2) {
            isDragging = false; 
            isPotentialClick = false; 
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            initialPinchDist = Math.hypot(dx, dy);
            pinchStartScale = globeScale;
        } else if (e.touches.length === 1) {
            handleStart(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false });
    
    window.addEventListener('touchmove', e => {
        e.preventDefault(); 
        if (e.touches.length === 2 && initialPinchDist) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.hypot(dx, dy);
            const scaleChange = dist / initialPinchDist;
            globeScale = Math.min(Math.max(0.5, pinchStartScale * scaleChange), 3);
            popupEl.classList.remove('active'); // Hide popup on zoom
        } else if (e.touches.length === 1) {
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
        }
    }, { passive: false });
    
    window.addEventListener('touchend', (e) => {
        if (e.touches.length < 2) initialPinchDist = null;
        if (e.touches.length === 0) {
            handleEnd();
            if (isPotentialClick && e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                handleClick({
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                isPotentialClick = false; 
            }
        }
    }, { passive: false });

    // --- Drawing Functions ---

    function rotateY(p, theta) {
        return {
            x: p.x * Math.cos(theta) - p.z * Math.sin(theta),
            y: p.y,
            z: p.x * Math.sin(theta) + p.z * Math.cos(theta)
        };
    }

    function rotateX(p, theta) {
        return {
            x: p.x,
            y: p.y * Math.cos(theta) - p.z * Math.sin(theta),
            z: p.y * Math.sin(theta) + p.z * Math.cos(theta)
        };
    }

    function project(p) {
        // Apply entrance zoom effect
        const entranceZoom = 0.1 + entranceProgress * 0.9;
        
        const scale = (800 / (800 + p.z)) * globeScale * entranceZoom;
        return {
            x: p.x * scale,
            y: p.y * scale,
            z: p.z,
            scale: scale
        };
    }

    function drawStars() {
        ctx.fillStyle = '#ffffff';
        stars.forEach(star => {
            star.opacity += star.speed;
            if (star.opacity > 1 || star.opacity < 0.2) {
                star.speed = -star.speed;
            }
            const alpha = Math.max(0, Math.min(1, star.opacity));
            // Made stars brighter by increasing base alpha range
            ctx.globalAlpha = alpha * (0.8 + Math.random() * 0.2); 
            
            // Optimization: Use fillRect for better performance
            ctx.fillRect(star.x, star.y, star.size, star.size);
        });
        ctx.globalAlpha = 1.0;
    }

    function easeOutExpo(x) {
        return x === 1 ? 1 : 1 - Math.pow(2, -10 * x);
    }

    // --- Render Loop ---
    
    function renderFrame(timestamp) {
        if (!startTime) startTime = timestamp;
        // 3 seconds duration for entrance
        const rawProgress = Math.min((timestamp - startTime) / 3500, 1);
        entranceProgress = easeOutExpo(rawProgress);

        const speedShake = (1 - entranceProgress) * 2; 

        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, width, height);
        
        const panOffset = (1 - entranceProgress) * -width * 0.8; 
        
        ctx.save();
        const shakeX = (Math.random() - 0.5) * speedShake;
        const shakeY = (Math.random() - 0.5) * speedShake;
        ctx.translate(width/2 + shakeX, height/2 + shakeY);

        // Draw Stars
        drawStars();
        
        // Restore context for globe
        ctx.restore();
        
        // --- Globe Layer ---
        ctx.translate(width/2 + panOffset, height/2); 

        if (!isDragging && entranceProgress > 0.9) {
            rotationY -= AUTO_ROTATION_SPEED; 
            if (Math.abs(velocityX) > 0.0001 || Math.abs(velocityY) > 0.0001) {
                rotationY += velocityX;
                rotationX += velocityY;
                velocityX *= 0.95;
                velocityY *= 0.95;
            }
        } else if (isDragging) {
            // Already updated in handleMove
        } else if (entranceProgress > 0.9 && Math.abs(velocityX) > 0.0001) {
             // Continue momentum if dragging stopped
             rotationY += velocityX;
             rotationX += velocityY;
             velocityX *= 0.95;
             velocityY *= 0.95;
        }
        
        waveOffset += WAVE_SPEED;

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        const drawBatch = (lines, color, width, isGrid, jitterScale = 1.0) => {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = width;

            const jitterFactor = (isGrid ? JITTER_AMOUNT : JITTER_AMOUNT * 0.5) * jitterScale;

            lines.forEach(line => {
                let prevPt = null;
                let isLineActive = false;

                for (let i=0; i<line.length; i++) {
                    const p = line[i];
                    let r = rotateY(p, rotationY);
                    r = rotateX(r, rotationX);
                    
                    if (r.z > 50) { 
                        prevPt = null;
                        isLineActive = false;
                        continue; 
                    }

                    const proj = project(r);

                    if (prevPt) {
                        const dist = Math.abs(proj.x - prevPt.x) + Math.abs(proj.y - prevPt.y);
                        
                        if (!isLineActive) {
                            ctx.moveTo(prevPt.x, prevPt.y);
                            isLineActive = true;
                        }

                        if (dist < 5) {
                            ctx.lineTo(proj.x, proj.y);
                        } else {
                            const steps = Math.floor(dist / LINE_SEGMENT_LENGTH);
                            if (steps > 0) {
                                for (let s = 1; s <= steps; s++) {
                                    const t = s / (steps + 1);
                                    let tx = prevPt.x + (proj.x - prevPt.x) * t;
                                    let ty = prevPt.y + (proj.y - prevPt.y) * t;
                                    
                                    tx += (Math.random() - 0.5) * jitterFactor * 2;
                                    ty += (Math.random() - 0.5) * jitterFactor * 2;
                                    
                                    ctx.lineTo(tx, ty);
                                }
                            }
                            ctx.lineTo(proj.x, proj.y);
                        }
                    }
                    prevPt = proj;
                }
            });
            ctx.stroke();
        };

        const drawSelectedFill = () => {
            if (!selectedCountryName) return;
            const country = countries.find(c => c.name === selectedCountryName);
            if (!country) return;

            // Using semi-transparent teal fill as per previous successful "highlight" logic
            ctx.fillStyle = 'rgba(0, 220, 190, 0.3)'; 
            
            country.rings.forEach(ring => {
                let zSum = 0;
                let validCount = 0;
                const projectedRing = [];
                for(let i=0; i<ring.length; i+=2) {
                    let r = rotateY(ring[i], rotationY);
                    r = rotateX(r, rotationX);
                    zSum += r.z;
                    validCount++;
                    projectedRing.push(project(r));
                }
                const avgZ = zSum / validCount;
                if (avgZ > 50) return;

                ctx.beginPath();
                if(projectedRing.length > 0) {
                    ctx.moveTo(projectedRing[0].x, projectedRing[0].y);
                    for(let i=1; i<projectedRing.length; i++) {
                        ctx.lineTo(projectedRing[i].x, projectedRing[i].y);
                    }
                    ctx.closePath();
                    ctx.fill();
                }
            });
        };

        // 1. Grid
        drawBatch(gridPoints, COLOR_GRID, GRID_WIDTH, true);
        
        // 2. Waves (Animated)
        const currentWaveLines = wavesData.map(w => {
            const currentLon = w.lon + waveOffset;
            const waveRadius = BASE_RADIUS * 1.005; 
            return [
                getSpherePoint(w.lat, currentLon - w.span, waveRadius),
                getSpherePoint(w.lat, currentLon, waveRadius),
                getSpherePoint(w.lat, currentLon + w.span, waveRadius)
            ];
        });
        drawBatch(currentWaveLines, COLOR_WAVES, WAVE_WIDTH, true);

        // 3. Map Outlines
        if (isDataLoaded) {
            const unselectedRings = [];
            const selectedRings = [];

            countries.forEach(c => {
                if (c.name === selectedCountryName) {
                    selectedRings.push(...c.rings.map(r => r.points3d));
                } else {
                    unselectedRings.push(...c.rings.map(r => r.points3d));
                }
            });

            if(unselectedRings.length > 0) {
                drawBatch(unselectedRings, COLOR_MAP, MAP_WIDTH, false);
            }
            
            // Selected Country Outline (Bright Teal) + Fill (processed above)
            drawSelectedFill(); // Draw fill behind outline
            if(selectedRings.length > 0) {
                drawBatch(selectedRings, COLOR_LAND_SELECTED, MAP_WIDTH * 1.8, false);
            }
        }

        // 4. Speaking Head Pointers
        drawPointers();

        requestAnimationFrame(renderFrame);
    }

    function drawPointers() {
        const pointerRadius = BASE_RADIUS * 1.02; // Float slightly above surface
        
        pointers.forEach(p => {
            // 1. Get 3D position
            const spherePt = getSpherePoint(p.lat, p.lon, pointerRadius);
            
            // 2. Rotate
            let r = rotateY(spherePt, rotationY);
            r = rotateX(r, rotationX);
            
            // 3. Check visibility (cull back-facing)
            if (r.z > 40) return; // Similar culling to map lines

            // 4. Project to 2D
            const proj = project(r);
            
            // 5. Draw Icon
            drawLocationPin(proj.x, proj.y, proj.scale, COLOR_POINTER);
            
            // 6. Draw Country Name Label
            // Calculate font size based on perspective scale, clamped to be legible but small
            // REDUCED SIZE: from 8 to 5 base size
            const fontSize = Math.max(6, 7 * proj.scale); 
            
            ctx.font = `500 ${fontSize}px 'DM Sans', sans-serif`;
            ctx.fillStyle = "rgba(255, 255, 255, 0.9)"; // Bright white for contrast
            ctx.textAlign = "center";
            ctx.textBaseline = "bottom";
            
            // Add shadow for readability over map lines/land
            ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 1;
            
            // Position above the pin tip
            const labelOffset = 18 * proj.scale;
            ctx.fillText(p.name.toUpperCase(), proj.x, proj.y - labelOffset);
            
            // Reset shadow
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
        });
    }

    function drawLocationPin(cx, cy, scale, color) {
        const s = 0.3 * scale; 
        
        ctx.fillStyle = color;
        ctx.strokeStyle = color;
        ctx.lineWidth = 0.1;
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';

        // 1. Draw Pin Body (Teardrop shape)
        ctx.beginPath();
        const pinPath = [
            {x: 0, y: 0},     // Tip
            {x: -3, y: -6},
            {x: -10, y: -18},
            {x: -13, y: -28}, // Left Bulge
            {x: -10, y: -38},
            {x: 0, y: -42},   // Top
            {x: 10, y: -38},
            {x: 13, y: -28},  // Right Bulge
            {x: 10, y: -18},
            {x: 3, y: -6},
            {x: 0, y: 0}      // Close to Tip
        ];

        let first = true;
        const jitter = 0.4;
        
        pinPath.forEach(pt => {
            const px = cx + pt.x * s + (Math.random() - 0.5) * jitter;
            const py = cy + pt.y * s + (Math.random() - 0.5) * jitter;
            if (first) {
                ctx.moveTo(px, py);
                first = false;
            } else {
                ctx.lineTo(px, py);
            }
        });
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // 2. Draw "Hole" in Pin (Dark circle)
        ctx.fillStyle = '#050508'; // Match background
        ctx.beginPath();
        const holeY = -28;
        const holeR = 5;
        
        for(let i=0; i<=10; i++) {
            const a = (i/10) * Math.PI * 2;
            // Add jitter to hole too
            const jx = Math.cos(a) * holeR * s + (Math.random() - 0.5) * jitter;
            const jy = (holeY * s) + Math.sin(a) * holeR * s + (Math.random() - 0.5) * jitter;
            
            if(i===0) ctx.moveTo(cx + jx, cy + jy);
            else ctx.lineTo(cx + jx, cy + jy);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
    }

    window.addEventListener('resize', resize);
    resize();
    initGrid();
    initWaves(); 
    initStars();
    startLoadingSequence(); // Start the loading text sequence
    loadMapData();
    requestAnimationFrame(renderFrame);

</script>
</body>
</html>
